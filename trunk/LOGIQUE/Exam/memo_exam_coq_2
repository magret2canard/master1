Lemma P3Q : forall P Q : Prop, (((P->Q)->Q)->Q) -> P -> Q

------------------------------------------------ assumption.
P:Prop, Q:Prop, ((P->Q)->Q)->Q, P, P->Q |--  P
------------------------------------------------ apply H0.
P:Prop, Q:Prop, ((P->Q)->Q)->Q, P, P->Q |--  Q
------------------------------------------------ intro H0.
P:Prop, Q:Prop, ((P->Q)->Q)->Q, P |-- (P->Q)->Q
------------------------------------------------ apply H.
P:Prop, Q:Prop, ((P->Q)->Q)->Q, P |-- Q
------------------------------------------------- intros P Q H p.
|-- forall P Q : Prop, (((P->Q)->Q)->Q) -> P -> Q

============

Lemma triple_neg : forall P:Prop, ~~~P -> ~P.

--------------------------------------------------- apply P3Q.
P:Prop |-- (((P->False)->False)->False) -> P->False
--------------------------------------------------- unfold not.
P:Prop |-- ~~~P -> ~P
----------------------------- intro P. 
|-- forall P:Prop, ~~~P -> ~P

==================================================================================

Lemma not_or_1 : forall P Q : Prop, ~(P \/ Q) -> ~P.

------------------------ assumption.
P:Prop, Q:Prop, P |-- P
----------------------------- left.
P:Prop, Q:Prop, P |-- P \/ Q
-------------------------------------- destruct H. (ou bien apply H.)
P:Prop, Q:Prop, ~(P \/ Q), P |-- False
-------------------------------------- intros P Q H p.
|-- forall P Q : Prop, ~(P \/ Q) -> ~P

============

Variable n : nat.
Hypothesis H : n=0 \/ n=2 -> n <> n.    (équivalent à n=0 \/ n=2 -> n = n -> False)

Lemma L1 : ~n = 0.


-------------------------------------- assumption.  ------------------------------ reflexivity.
H, (n = 0 \/ n = 2) |-- n = 0 \/ n = 2              H, (n = 0 \/ n = 2) |-- n = n
---------------------------------------------------------------------------------- apply H. (ou destruct H.)
H, (n = 0 \/ n = 2) |-- False
------------------------------ intro H0.
H |-- ~(n = 0 \/ n = 2)
------------------------ apply not_or_1 with (n=2). (P := (n=0) et Q:= (n=2))
H |-- ~ n = 0

==================================================================================

Lemma de_morgan_1 : forall P Q: Prop, ~ (P \/ Q) <-> ~P /\ ~Q.

---------------------------- assumption             ---------------------------- assumption
P:Prop, Q:Prop, ~Q, P  |-- P                        P:Prop, Q:Prop, ~P, Q |-- Q
------------------------------------ destruct nP.   ----------------------------------- destruct nQ. 
P:Prop, Q:Prop, ~P, ~Q, P  |-- False                P:Prop, Q:Prop, ~P, ~Q, Q |-- False
--------------------------------------------------------------------------------------- destruct H as [p | q].
P:Prop, Q:Prop, ~P, ~Q, P \/ Q |-- False
----------------------------------------- intro H.
P:Prop, Q:Prop, ~P, ~Q |-- ~ (P \/ Q)
------------------------------------------ intros [nP nQ]. 
P:Prop, Q:Prop |-- ~P /\ ~Q -> ~ (P \/ Q)
----------------------------------------- split. (2eme partie)
.
.
.
----------------------------------- assumption.    ----------------------------------- assumption.
P:Prop, Q:Prop, ~ (P \/ Q), P |-- P                P:Prop, Q:Prop, ~ (P \/ Q), Q |-- Q
---------------------------------------- left.     --------------------------------------- right
P:Prop, Q:Prop, ~ (P \/ Q), P |-- P \/ Q           P:Prop, Q:Prop, ~ (P \/ Q), Q |-- P \/ Q
---------------------------------------- apply H.  --------------------------------------- apply H. 
P:Prop, Q:Prop, ~ (P \/ Q), P |-- False            P:Prop, Q:Prop, ~ (P \/ Q), Q |-- False
---------------------------------------- intro p.  --------------------------------------- intro q.
P:Prop, Q:Prop, ~ (P \/ Q) |-- ~P                  P:Prop, Q:Prop, ~ (P \/ Q) |-- ~Q
------------------------------------------------------------------------------------ split.
P:Prop, Q:Prop, ~ (P \/ Q) |-- ~P /\ ~Q
----------------------------------------- intro H.     
P:Prop, Q:Prop |-- ~ (P \/ Q) -> ~P /\ ~Q              
------------------------------------------ split. (1ere partie)
P:Prop, Q:Prop |-- ~ (P \/ Q) <-> ~P /\ ~Q
--------------------------------------------- intros P Q.
|-- forall P Q: Prop, ~ (P \/ Q) <-> ~P /\ ~Q


==================================================================================

Lemma de_morgan_2 : forall P Q: Prop, ~ P \/ ~Q  -> ~(P /\ Q).

--------------------------- assumption.           --------------------------- assumption.
P:Prop, Q:Prop, P, Q |-- P                        P:Prop, Q:Prop, P, Q |-- Q
----------------------------------- destruct nP.  ----------------------------------- destruct nQ.
P:Prop, Q:Prop, ~P, P, Q |-- False.               P:Prop, Q:Prop, ~Q, P, Q |-- False.
------------------------------------------------------------------------- intros P Q [nP | nQ] [p q].
|-- forall P Q: Prop, ~ P \/ ~Q  -> ~(P /\ Q)


==================================================================================

Lemma all_perm : forall (A:Type) (P:A -> A -> Prop), (forall x y:A, P x y) -> forall x y:A, P y x.


------------------------------------------- apply H.
A, P, (forall x y:A, P x y), x, y |-- P y x
---------------------------------------------------------- intros x y.
A, P, (forall x y:A, P x y) |-- forall x y:A, P y x
------------------------------------------------------------------------------------ intros A P H. 
|-- forall (A:Type) (P:A -> A -> Prop), (forall x y:A, P x y) -> forall x y:A, P y x

==================================================================================

Lemma resolution : forall (A:Type) (P Q R S:A -> Prop), (forall a:A, Q a -> R a -> S a) -> 
															   (forall b:A, P b -> Q b) -> 
															   forall c:A, P c -> R c -> S c.

------------------------------- assumption.
Γ, H, H0, c, P c, R c  |--  P c
-------------------------------- apply H0.    ------------------------------ assumption. 
Γ, H, H0, c, P c, R c  |--  Q c               Γ, H, H0, c, P c, R c  |--  R c
------------------------------------------------------------------------------------------ apply H.
Γ, H:(forall a:A, Q a -> R a -> S a), H0:(forall b:A, P b -> Q b), c, P c, R c } |--  S c
---------------------------------------------------------------------------------------------- intros c Hp Hr.
Γ, (forall a:A, Q a -> R a -> S a), (forall b:A, P b -> Q b) |-- forall c:A, P c -> R c -> S c
---------------------------------------------------------------------------------------------------------------- intros H H0. 
Γ : { A, P, Q, R, S } |-- (forall a:A, Q a -> R a -> S a) -> (forall b:A, P b -> Q b) -> forall c:A, P c -> R c -> S c
------------------------------------------------------------------------------------------------------------------------------------- intros A P Q R S. 
|-- forall (A:Type) (P Q R S:A -> Prop), (forall a:A, Q a -> R a -> S a) -> (forall b:A, P b -> Q b) -> forall c:A, P c -> R c -> S c

==================================================================================

Lemma not_ex_forall_not : forall (A: Type) (P: A -> Prop), ~(exists x, P x) <-> forall x, ~ P x.


----------------- assumption.
Γ, x, P x |-- P x
------------------------------ exists x.                   -------------------------------------- assumption.
Γ, x, P x |--  exists x0, P x0                              Γ, (forall x, ~ P x), x, P x |-- P x
------------------------------------------ destruct H.     ---------------------------------------- destruct (H x). 
Γ, ~(exists x, P x), x, P x |--  False                      Γ, (forall x, ~ P x), x, P x |-- False
------------------------------------------ intros H x Hx.  ---------------------------------------- intros H [x Hx].
Γ |-- ~(exists x, P x) -> forall x, ~ P x                   Γ |-- forall x, ~ P x -> ~(exists x, P x)
------------------------------------------------------------------------------------------------------ split.
Γ : {A P} |-- ~(exists x, P x) <-> forall x, ~ P x
-------------------------------------------------------------------------- intros A P.
|-- forall (A: Type) (P: A -> Prop), ~(exists x, P x) <-> forall x, ~ P x

==================================================================================

Lemma ex_not_forall_not : forall (A: Type) (P: A -> Prop), (exists x, P x) -> ~ (forall x, ~ P x).


------------------------------------- assumption.
Γ, x, P x, (forall x, ~ P x) |-- P x
------------------------------------------------ destruct (H x).
Γ : {A, P}, x, P x, (forall x, ~ P x) |-- False
--------------------------------------------------------------------------- intros A P [x Hx] H.
|-- forall (A: Type) (P: A -> Prop), (exists x, P x) -> ~ (forall x, ~ P x)

==================================================================================

Lemma diff_sym : forall (A:Type) (a b : A), a <> b -> b <> a.

--------------------------- assumption.
Γ, a <> b, b = a |-- b = a
--------------------------- symmetry.
Γ, b = a |-- a = b
--------------------------- destruct H.
Γ, a <> b, b = a |-- False
--------------------------- intro H0.
Γ, a <> b |-- b <> a
----------------------------------- intro H.
Γ : {A, a, b} |-- a <> b -> b <> a
----------------------------------------------- intros A a b.
|-- forall (A:Type) (a b : A), a <> b -> b <> a

==================================================================================

Lemma fun_diff :  forall (A B:Type) (f : A -> B) (a b : A), f a <> f b -> a <> b.


----------------------- reflexivity.
Γ, a = b |-- f b = f b
----------------------- rewrite H0.
Γ, a = b |-- f a = f b
------------------------------- destruct H.
Γ, f a <> f b, a = b |-- False
--------------------------------------------- intros H H0.
Γ : {A, B, f, a, b} |-- f a <> f b -> a <> b
------------------------------------------------------------------ intros A B f a b. 
|-- forall (A B:Type) (f : A -> B) (a b : A), f a <> f b -> a <> b










